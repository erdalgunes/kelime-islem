name: CodeRabbit Fix Handler

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  parse-and-trigger:
    name: Parse CodeRabbit Comments and Trigger Fixes
    runs-on: ubuntu-latest
    if: |
      (github.event.comment.user.login == 'coderabbitai' ||
       github.event.comment.user.type == 'Bot') &&
      (contains(github.event.comment.body, 'suggestion') ||
       contains(github.event.comment.body, 'issue') ||
       contains(github.event.comment.body, 'bug') ||
       contains(github.event.comment.body, 'security') ||
       contains(github.event.comment.body, 'performance'))

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse CodeRabbit Comment
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const issues = [];

            // Parse different issue patterns from CodeRabbit
            const patterns = {
              bug: /(?:bug|error|exception|fix):\s*([^\n]+)/gi,
              security: /(?:security|vulnerability|CVE|exposure):\s*([^\n]+)/gi,
              performance: /(?:performance|optimization|slow|inefficient):\s*([^\n]+)/gi,
              style: /(?:style|formatting|lint|convention):\s*([^\n]+)/gi,
              test: /(?:test|coverage|missing test):\s*([^\n]+)/gi,
              documentation: /(?:documentation|docs|comment):\s*([^\n]+)/gi
            };

            for (const [type, pattern] of Object.entries(patterns)) {
              let match;
              while ((match = pattern.exec(comment)) !== null) {
                issues.push({
                  type,
                  description: match[1].trim(),
                  line: extractLineNumber(match[1])
                });
              }
            }

            // Extract suggestions from markdown code blocks
            const suggestionPattern = /```suggestion\n([\s\S]*?)```/g;
            let suggestionMatch;
            while ((suggestionMatch = suggestionPattern.exec(comment)) !== null) {
              issues.push({
                type: 'suggestion',
                description: 'Code suggestion provided',
                code: suggestionMatch[1]
              });
            }

            function extractLineNumber(text) {
              const lineMatch = text.match(/line\s+(\d+)/i);
              return lineMatch ? parseInt(lineMatch[1]) : null;
            }

            core.setOutput('issues', JSON.stringify(issues));
            core.setOutput('issue_count', issues.length);

            // Get PR details
            const pr = context.payload.issue || context.payload.pull_request;
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_title', pr.title);
            core.setOutput('repository', context.repo.repo);
            core.setOutput('owner', context.repo.owner);

      - name: Trigger Codegen.com Workflow
        if: steps.parse.outputs.issue_count > 0
        id: codegen
        run: |
          # Prepare the payload for Codegen.com
          ISSUES='${{ steps.parse.outputs.issues }}'
          PR_NUMBER='${{ steps.parse.outputs.pr_number }}'
          REPO='${{ steps.parse.outputs.repository }}'
          OWNER='${{ steps.parse.outputs.owner }}'

          # Create a dispatch event for Codegen integration
          # Note: This would normally call Codegen.com API directly
          # For now, we'll trigger a GitHub workflow that integrates with Codegen

          echo "issues=$ISSUES" >> $GITHUB_OUTPUT
          echo "triggered=true" >> $GITHUB_OUTPUT

      - name: Create Fix Branch
        if: steps.parse.outputs.issue_count > 0
        run: |
          PR_NUMBER='${{ steps.parse.outputs.pr_number }}'
          BRANCH_NAME="auto-fix/pr-${PR_NUMBER}-$(date +%s)"

          # Create a new branch for fixes
          git checkout -b "$BRANCH_NAME"

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Comment on PR
        if: steps.parse.outputs.issue_count > 0
        uses: actions/github-script@v7
        with:
          script: |
            const issueCount = ${{ steps.parse.outputs.issue_count }};
            const issues = JSON.parse('${{ steps.parse.outputs.issues }}');

            // Group issues by type
            const groupedIssues = issues.reduce((acc, issue) => {
              if (!acc[issue.type]) acc[issue.type] = [];
              acc[issue.type].push(issue);
              return acc;
            }, {});

            let comment = `## ðŸ¤– Auto-Fix Handler Activated\n\n`;
            comment += `I've detected **${issueCount} issues** from CodeRabbit's review that I can attempt to fix automatically.\n\n`;
            comment += `### Issues to be addressed:\n`;

            for (const [type, typeIssues] of Object.entries(groupedIssues)) {
              const emoji = {
                bug: 'ðŸ›',
                security: 'ðŸ”’',
                performance: 'âš¡',
                style: 'ðŸŽ¨',
                test: 'ðŸ§ª',
                documentation: 'ðŸ“š',
                suggestion: 'ðŸ’¡'
              }[type] || 'ðŸ“';

              comment += `\n${emoji} **${type.charAt(0).toUpperCase() + type.slice(1)}** (${typeIssues.length}):\n`;
              typeIssues.forEach((issue, i) => {
                comment += `${i + 1}. ${issue.description.substring(0, 100)}${issue.description.length > 100 ? '...' : ''}\n`;
              });
            }

            comment += `\n### Next Steps:\n`;
            comment += `1. ðŸ”„ Generating fixes using AI agents\n`;
            comment += `2. ðŸ§ª Testing fixes in isolated environment\n`;
            comment += `3. âœ… Creating fix PR if all tests pass\n`;
            comment += `4. ðŸ‘€ Requesting human review for approval\n\n`;
            comment += `*Processing will begin shortly. I'll update this comment with progress.*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.parse.outputs.pr_number }},
              body: comment
            });

  trigger-fix-workflow:
    name: Trigger Fix Generation
    needs: parse-and-trigger
    runs-on: ubuntu-latest
    if: needs.parse-and-trigger.outputs.triggered == 'true'

    steps:
      - name: Dispatch Fix Workflow
        uses: peter-evans/repository-dispatch@v3
        with:
          event-type: codegen-fix
          client-payload: |
            {
              "issues": ${{ needs.parse-and-trigger.outputs.issues }},
              "pr_number": "${{ needs.parse-and-trigger.outputs.pr_number }}",
              "branch_name": "${{ needs.parse-and-trigger.outputs.branch_name }}"
            }