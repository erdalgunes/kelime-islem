name: Sprint Metrics

on:
  schedule:
    # Run every Friday at 4 PM UTC (end of sprint)
    - cron: '0 16 * * 5'
  workflow_dispatch:
    inputs:
      sprint_number:
        description: 'Sprint number to analyze'
        required: true
        type: string

permissions:
  contents: read
  issues: write
  pull-requests: read
  discussions: write

env:
  # Sprint configuration - can be overridden via repository variables
  SPRINT_ANCHOR_DATE: ${{ vars.SPRINT_ANCHOR_DATE || '2025-01-01' }}
  SPRINT_DURATION_DAYS: ${{ vars.SPRINT_DURATION_DAYS || '14' }}

jobs:
  collect-metrics:
    name: Collect Sprint Metrics
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: Calculate sprint dates
        id: dates
        run: |
          # Use Python for cross-platform date calculations
          python3 << 'EOF'
          import os
          from datetime import datetime, timedelta, timezone

          # Project anchor date - configurable via repository variables
          anchor_date_str = os.environ.get('SPRINT_ANCHOR_DATE', '2025-01-01')
          sprint_duration = int(os.environ.get('SPRINT_DURATION_DAYS', '14'))

          # Parse anchor date (assumes YYYY-MM-DD format)
          year, month, day = map(int, anchor_date_str.split('-'))
          ANCHOR_DATE = datetime(year, month, day, tzinfo=timezone.utc)

          if os.environ.get('GITHUB_EVENT_NAME') == 'workflow_dispatch':
              sprint = int('${{ github.event.inputs.sprint_number }}')
          else:
              # Calculate current sprint based on today's date (UTC)
              days_since_anchor = (datetime.now(timezone.utc) - ANCHOR_DATE).days
              sprint = (days_since_anchor // sprint_duration) + 1

          # Calculate sprint start and end dates using configurable duration
          sprint_start = ANCHOR_DATE + timedelta(days=(sprint - 1) * sprint_duration)
          sprint_end = sprint_start + timedelta(days=sprint_duration - 1)

          # Write to GitHub output
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"sprint_number={sprint}\n")
              f.write(f"start_date={sprint_start.strftime('%Y-%m-%d')}\n")
              f.write(f"end_date={sprint_end.strftime('%Y-%m-%d')}\n")

          print(f"Sprint {sprint}: {sprint_start.strftime('%Y-%m-%d')} to {sprint_end.strftime('%Y-%m-%d')}")
          EOF

      - name: Collect issue metrics
        id: issues
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const sprint = ${{ steps.dates.outputs.sprint_number }};
            const startDate = '${{ steps.dates.outputs.start_date }}';
            const endDate = '${{ steps.dates.outputs.end_date }}';

            // Get issues in current sprint (listForRepo returns both issues and PRs)
            const sprintLabel = `sprint/${sprint}`;
            const items = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: sprintLabel,
              state: 'all',
              per_page: 100
            });

            // Filter out pull requests (they have a pull_request property)
            const issues = items.filter(i => !i.pull_request);

            // Calculate metrics using assignees array instead of deprecated assignee field
            const metrics = {
              total: issues.length,
              completed: issues.filter(i => i.state === 'closed').length,
              inProgress: issues.filter(i => i.state === 'open' && Array.isArray(i.assignees) && i.assignees.length > 0).length,
              notStarted: issues.filter(i => i.state === 'open' && (!Array.isArray(i.assignees) || i.assignees.length === 0)).length,
              bugs: issues.filter(i => i.labels.some(l => l.name === 'bug')).length,
              features: issues.filter(i => i.labels.some(l => l.name === 'enhancement')).length,
            };

            // Calculate story points
            let totalPoints = 0;
            let completedPoints = 0;

            for (const issue of issues) {
              const sizeLabel = issue.labels.find(l => l.name.startsWith('size/'));
              let points = 0;

              if (sizeLabel) {
                const size = sizeLabel.name.replace('size/', '');
                points = {
                  'XS': 1,
                  'S': 2,
                  'M': 5,
                  'L': 8,
                  'XL': 13
                }[size] || 0;
              }

              totalPoints += points;
              if (issue.state === 'closed') {
                completedPoints += points;
              }
            }

            metrics.totalPoints = totalPoints;
            metrics.completedPoints = completedPoints;
            metrics.velocity = completedPoints;

            return metrics;

      - name: Collect PR metrics
        id: prs
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const startDate = new Date('${{ steps.dates.outputs.start_date }}');
            const endDate = new Date('${{ steps.dates.outputs.end_date }}');

            const prs = await github.paginate(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100
            });

            // Enhanced PR Sprint Attribution Logic
            // Problem: PRs can span multiple sprints (created in sprint 1, merged in sprint 2)
            // Solution: Attribute each PR to exactly ONE sprint based on priority:
            //   1. Merged date (highest priority) - PR delivered value in this sprint
            //   2. Closed date (if not merged) - PR was resolved in this sprint
            //   3. Created date (if still open) - PR work started in this sprint
            // This prevents double-counting and provides accurate velocity metrics
            const sprintPRs = [];
            const processedPRNumbers = new Set(); // Track PRs to prevent double-counting

            for (const pr of prs) {
              const createdAt = new Date(pr.created_at);
              const mergedAt = pr.merged_at ? new Date(pr.merged_at) : null;
              const closedAt = pr.closed_at ? new Date(pr.closed_at) : null;

              // Determine which sprint this PR primarily belongs to
              // Priority: merged > closed > created
              let primarySprintMatch = false;

              if (mergedAt && mergedAt >= startDate && mergedAt <= endDate) {
                // PR was merged in this sprint - primary attribution
                primarySprintMatch = true;
              } else if (closedAt && !mergedAt && closedAt >= startDate && closedAt <= endDate) {
                // PR was closed (not merged) in this sprint
                primarySprintMatch = true;
              } else if (createdAt >= startDate && createdAt <= endDate && pr.state === 'open') {
                // PR was created in this sprint and is still open
                primarySprintMatch = true;
              }

              // Only include if this PR belongs to this sprint and hasn't been counted yet
              if (primarySprintMatch && !processedPRNumbers.has(pr.number)) {
                sprintPRs.push(pr);
                processedPRNumbers.add(pr.number);
              }
            }

            // Calculate metrics based on activity within the sprint window
            const prMetrics = {
              total: sprintPRs.length,
              // Count PRs merged during the sprint (by merged_at)
              merged: sprintPRs.filter(pr => {
                if (!pr.merged_at) return false;
                const mergedAt = new Date(pr.merged_at);
                return mergedAt >= startDate && mergedAt <= endDate;
              }).length,
              // Count PRs closed (not merged) during the sprint (by closed_at)
              closed: sprintPRs.filter(pr => {
                if (pr.merged_at || !pr.closed_at) return false;
                const closedAt = new Date(pr.closed_at);
                return closedAt >= startDate && closedAt <= endDate;
              }).length,
              // Count PRs that are still open (created during sprint and still open)
              open: sprintPRs.filter(pr => {
                if (pr.state !== 'open') return false;
                const createdAt = new Date(pr.created_at);
                return createdAt >= startDate && createdAt <= endDate;
              }).length
            };

            // Calculate average review time only for PRs merged within the sprint window
            let totalReviewTime = 0;
            let reviewedPRs = 0;

            for (const pr of sprintPRs) {
              // Only count PRs that were merged during this sprint
              if (!pr.merged_at) continue;
              const mergedAt = new Date(pr.merged_at);
              if (mergedAt < startDate || mergedAt > endDate) continue;

              const created = new Date(pr.created_at);
              const reviewTime = (mergedAt - created) / (1000 * 60 * 60); // hours
              totalReviewTime += reviewTime;
              reviewedPRs++;
            }

            prMetrics.avgReviewTime = reviewedPRs > 0
              ? (totalReviewTime / reviewedPRs).toFixed(1)
              : 0;

            return prMetrics;

      - name: Generate burndown data
        id: burndown
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const sprint = ${{ steps.dates.outputs.sprint_number }};
            const startDate = new Date('${{ steps.dates.outputs.start_date }}');
            const endDate = new Date('${{ steps.dates.outputs.end_date }}');

            // Get all events for sprint issues
            const sprintLabel = `sprint/${sprint}`;
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: sprintLabel,
              state: 'all',
              per_page: 100
            });

            // Create daily burndown
            const burndown = [];
            const totalDays = 14;

            for (let day = 0; day < totalDays; day++) {
              const date = new Date(startDate);
              date.setDate(date.getDate() + day);

              const openOnDay = issues.filter(issue => {
                const created = new Date(issue.created_at);
                const closed = issue.closed_at ? new Date(issue.closed_at) : null;

                return created <= date && (!closed || closed > date);
              }).length;

              burndown.push({
                day,
                date: date.toISOString().split('T')[0],
                remaining: openOnDay
              });
            }

            return burndown;

      - name: Create metrics report
        id: report
        run: |
          # Extract metrics values
          issues_completed=${{ fromJson(steps.issues.outputs.result).completed }}
          issues_total=${{ fromJson(steps.issues.outputs.result).total }}
          issues_in_progress=${{ fromJson(steps.issues.outputs.result).inProgress }}
          issues_not_started=${{ fromJson(steps.issues.outputs.result).notStarted }}

          points_completed=${{ fromJson(steps.issues.outputs.result).completedPoints }}
          points_total=${{ fromJson(steps.issues.outputs.result).totalPoints }}
          points_velocity=${{ fromJson(steps.issues.outputs.result).velocity }}

          bugs_count=${{ fromJson(steps.issues.outputs.result).bugs }}
          features_count=${{ fromJson(steps.issues.outputs.result).features }}

          prs_total=${{ fromJson(steps.prs.outputs.result).total }}
          prs_merged=${{ fromJson(steps.prs.outputs.result).merged }}
          prs_closed=${{ fromJson(steps.prs.outputs.result).closed }}
          prs_open=${{ fromJson(steps.prs.outputs.result).open }}
          prs_avg_review=${{ fromJson(steps.prs.outputs.result).avgReviewTime }}

          # Calculate percentages safely
          if [ "$issues_total" -eq 0 ]; then
            issues_pct="N/A"
          else
            issues_pct=$(( issues_completed * 100 / issues_total ))
            issues_pct="${issues_pct}%"
          fi

          if [ "$points_total" -eq 0 ]; then
            points_pct="N/A"
          else
            points_pct=$(( points_completed * 100 / points_total ))
            points_pct="${points_pct}%"
          fi

          # Export for use in heredoc
          export issues_completed issues_total issues_in_progress issues_not_started issues_pct
          export points_completed points_total points_velocity points_pct
          export bugs_count features_count
          export prs_total prs_merged prs_closed prs_open prs_avg_review

          cat > sprint-metrics.md << EOF
          # Sprint ${{ steps.dates.outputs.sprint_number }} Metrics Report

          **Period**: ${{ steps.dates.outputs.start_date }} to ${{ steps.dates.outputs.end_date }}

          ## 📊 Sprint Overview

          ### Issues
          - **Total Issues**: ${issues_total}
          - **Completed**: ${issues_completed}
          - **In Progress**: ${issues_in_progress}
          - **Not Started**: ${issues_not_started}

          ### Story Points
          - **Committed**: ${points_total} points
          - **Completed**: ${points_completed} points
          - **Velocity**: ${points_velocity} points

          ### Issue Types
          - **Bugs**: ${bugs_count}
          - **Features**: ${features_count}

          ## 🔄 Pull Requests

          - **Total PRs**: ${prs_total}
          - **Merged**: ${prs_merged}
          - **Closed (not merged)**: ${prs_closed}
          - **Still Open**: ${prs_open}
          - **Avg Review Time**: ${prs_avg_review} hours

          ## 📈 Completion Rate

          \`\`\`
          Issues: ${issues_completed}/${issues_total} (${issues_pct})
          Points: ${points_completed}/${points_total} (${points_pct})
          \`\`\`

          ## 🎯 Sprint Goals Achievement

          Review sprint goals in the planning discussion to assess achievement.

          ## 📝 Notes

          - This report is automatically generated
          - For detailed analysis, check GitHub Projects
          - Discuss these metrics in the sprint retrospective

          ---

          *Generated on $(date +"%Y-%m-%d %H:%M:%S UTC")*
          EOF

      - name: Post metrics to discussion
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('sprint-metrics.md', 'utf8');

            // Dynamically resolve discussion category
            let categoryId = null;
            const targetCategoryName = 'Metrics';
            const alternativeCategoryNames = ['General', 'Announcements'];

            try {
              // Get repository ID and discussion categories
              const query = `
                query($owner: String!, $name: String!) {
                  repository(owner: $owner, name: $name) {
                    id
                    discussionCategories(first: 100) {
                      nodes {
                        id
                        name
                        slug
                      }
                    }
                  }
                }
              `;

              const result = await github.graphql(query, {
                owner: context.repo.owner,
                name: context.repo.repo
              });

              const repositoryId = result.repository.id;
              const categories = result.repository.discussionCategories.nodes;
              console.log(`Repository ID: ${repositoryId}`);
              console.log(`Found ${categories.length} discussion categories`);

              // Try to find the target category
              let category = categories.find(c => c.name === targetCategoryName);

              // If not found, try alternative category names
              if (!category) {
                for (const altName of alternativeCategoryNames) {
                  category = categories.find(c => c.name === altName);
                  if (category) {
                    console.log(`Using alternative category: ${altName}`);
                    break;
                  }
                }
              }

              // If still not found, use the first available category
              if (!category && categories.length > 0) {
                category = categories[0];
                console.log(`Using first available category: ${category.name}`);
              }

              if (category) {
                categoryId = category.id;
                console.log(`Selected category: ${category.name} (${category.id})`);
              } else {
                throw new Error('No discussion categories found in repository');
              }

              // Create the discussion
              await github.graphql(`
                mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
                  createDiscussion(input: {
                    repositoryId: $repositoryId,
                    categoryId: $categoryId,
                    title: $title,
                    body: $body
                  }) {
                    discussion {
                      id
                      url
                    }
                  }
                }
              `, {
                repositoryId: repositoryId,
                categoryId: categoryId,
                title: `Sprint ${{ steps.dates.outputs.sprint_number }} Metrics Report`,
                body: report
              });

              console.log('✅ Metrics report posted to discussions successfully');
            } catch (error) {
              // If discussions are not enabled or categories don't exist, create an issue instead
              console.log(`Could not post to discussions: ${error.message}`);
              console.log('Falling back to creating an issue instead...');

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Sprint ${{ steps.dates.outputs.sprint_number }} Metrics Report`,
                body: report,
                labels: ['metrics', 'sprint-report']
              });

              console.log('✅ Metrics report posted as an issue');
            }

      - name: Update project insights
        if: success()
        run: |
          echo "✅ Sprint metrics collected and posted successfully"
          echo "📊 Check the Discussions tab for the full report"

  velocity-trend:
    name: Calculate Velocity Trend
    runs-on: ubuntu-latest
    needs: collect-metrics
    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: Calculate velocity trend
        id: trend
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            try {
              // Try to get discussions first
              const discussions = await github.rest.discussions.list({
                owner: context.repo.owner,
                repo: context.repo.repo
              }).catch(() => ({ data: [] }));

              // Also check issues as fallback
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'metrics,sprint-report',
                state: 'all',
                per_page: 10
              });

              // Combine both sources
              const allReports = [
                ...discussions.data.filter(d => d.title.includes('Sprint') && d.title.includes('Metrics')),
                ...issues.data.filter(i => i.title.includes('Sprint') && i.title.includes('Metrics'))
              ];

              // Extract velocity from previous reports
              const velocities = allReports
                .slice(0, 5)
                .map(item => {
                  const body = item.body || '';
                  const match = body.match(/Velocity:\s*(\d+)\s*points/);
                  return match ? parseInt(match[1]) : 0;
                })
                .filter(v => v > 0);  // Only include non-zero velocities

              // Calculate trend if we have data
              if (velocities.length > 0) {
                const avgVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;
                const trend = velocities.length > 1 && velocities[0] > avgVelocity
                  ? 'increasing'
                  : 'stable';

                console.log(`Found ${velocities.length} previous sprints`);
                console.log(`Average velocity: ${avgVelocity.toFixed(1)}`);
                console.log(`Trend: ${trend}`);

                return { avgVelocity: avgVelocity.toFixed(1), trend, hasData: true };
              } else {
                console.log('No previous sprint data found');
                return { avgVelocity: 0, trend: 'no data', hasData: false };
              }
            } catch (error) {
              console.log(`Error calculating velocity trend: ${error.message}`);
              return { avgVelocity: 0, trend: 'error', hasData: false };
            }

      - name: Update velocity badge
        if: success()
        run: |
          echo "📈 Velocity trend: ${{ fromJson(steps.trend.outputs.result).trend }}"
          echo "📊 Average velocity: ${{ fromJson(steps.trend.outputs.result).avgVelocity }} points"

  notify-on-failure:
    name: Notify on Workflow Failure
    runs-on: ubuntu-latest
    needs: collect-metrics
    if: failure()
    steps:
      - name: Create failure notification issue
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const workflowUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const date = new Date().toISOString().split('T')[0];

            // Create an issue to notify about the failure
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `🚨 Sprint Metrics Workflow Failed - ${date}`,
              body: `## Workflow Failure Notification

            The Sprint Metrics workflow has failed to complete successfully.

            **Workflow Run**: [View Failed Run](${workflowUrl})
            **Date**: ${date}
            **Triggered by**: ${context.eventName}

            ### Action Required
            Please review the workflow logs to identify the issue and take corrective action.

            ### Common Issues
            - API rate limits exceeded
            - Missing permissions for discussions/issues
            - Invalid sprint configuration
            - GraphQL query failures

            @erdalgunes - Please investigate this failure.`,
              labels: ['bug', 'automation', 'urgent']
            });

            console.log('✅ Failure notification issue created');

      - name: Post to Slack (if configured)
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST $SLACK_WEBHOOK_URL \
              -H 'Content-Type: application/json' \
              -d "{
                \"text\": \"🚨 Sprint Metrics workflow failed!\",
                \"attachments\": [{
                  \"color\": \"danger\",
                  \"title\": \"Workflow Failure\",
                  \"text\": \"The Sprint Metrics collection failed. Please check the workflow logs.\",
                  \"fields\": [{
                    \"title\": \"Repository\",
                    \"value\": \"${{ github.repository }}\",
                    \"short\": true
                  }, {
                    \"title\": \"Run ID\",
                    \"value\": \"${{ github.run_id }}\",
                    \"short\": true
                  }]
                }]
              }"
          fi
